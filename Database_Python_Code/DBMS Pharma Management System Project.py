#!/usr/bin/env python3
"""
Optimized Pharmacy Management System (Oracle + Python)

Usage:
  - Set environment variables: DB_USER, DB_PASS, DB_HOST, DB_PORT, DB_SERVICE
    e.g.
      export DB_USER=system
      export DB_PASS=root
      export DB_HOST=localhost
      export DB_PORT=1521
      export DB_SERVICE=xepdb1

  - Run: python pharmacy_app.py
"""

from __future__ import annotations
import os
import sys
import logging
from typing import List, Optional, Tuple
from datetime import datetime
import oracledb as cx_Oracle

# --------------- Logging Setup ---------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)-7s | %(message)s"
)
log = logging.getLogger("pharmacy")

# --------------- DB Configuration (env-friendly) ---------------
DB_USER = os.getenv("DB_USER", "system")
DB_PASS = os.getenv("DB_PASS", "root")
DB_HOST = os.getenv("DB_HOST", "localhost")
DB_PORT = int(os.getenv("DB_PORT", "1521"))
DB_SERVICE = os.getenv("DB_SERVICE", "xepdb1")

# Build DSN
DB_DSN = cx_Oracle.makedsn(DB_HOST, DB_PORT, service_name=DB_SERVICE)

# --------------- SQL constants (centralized) ---------------
SQL_CREATE_SUPPLIERS = """
CREATE TABLE Suppliers (
    supplier_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(120) NOT NULL,
    contact_email VARCHAR2(120),
    phone VARCHAR2(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
"""

SQL_CREATE_CUSTOMERS = """
CREATE TABLE Customers (
    customer_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(120) NOT NULL,
    phone VARCHAR2(20),
    email VARCHAR2(120),
    address VARCHAR2(300),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
"""

SQL_CREATE_MEDICINES = """
CREATE TABLE Medicines (
    medicine_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(200) NOT NULL,
    pharma_form VARCHAR2(50),
    strength VARCHAR2(50),
    unit_price NUMBER(10,2) DEFAULT 0,
    supplier_id NUMBER,
    expiry_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_med_supplier FOREIGN KEY (supplier_id) REFERENCES Suppliers(supplier_id)
)
"""

SQL_CREATE_INVENTORY = """
CREATE TABLE Inventory (
    medicine_id NUMBER PRIMARY KEY,
    qty NUMBER DEFAULT 0,
    min_threshold NUMBER DEFAULT 10,
    CONSTRAINT fk_inv_med FOREIGN KEY(medicine_id) REFERENCES Medicines(medicine_id)
)
"""

SQL_CREATE_ORDERS = """
CREATE TABLE Orders (
    order_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_date DATE DEFAULT SYSDATE,
    customer_id NUMBER,
    total_amount NUMBER(12,2),
    status VARCHAR2(20),
    CONSTRAINT fk_ord_cust FOREIGN KEY(customer_id) REFERENCES Customers(customer_id)
)
"""

SQL_CREATE_ORDER_ITEMS = """
CREATE TABLE Order_Items (
    order_item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id NUMBER,
    medicine_id NUMBER,
    quantity NUMBER,
    unit_price NUMBER(10,2),
    line_total NUMBER(12,2),
    CONSTRAINT fk_oi_order FOREIGN KEY(order_id) REFERENCES Orders(order_id)
)
"""

SQL_CREATE_AUDIT = """
CREATE TABLE Audit_Log (
    audit_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    action_by VARCHAR2(100),
    action VARCHAR2(100),
    object_name VARCHAR2(100),
    details VARCHAR2(2000),
    action_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
"""

SQL_CHK_PRICE = "ALTER TABLE Medicines ADD (CONSTRAINT chk_price_nonneg CHECK (unit_price >= 0))"

SQL_CREATE_VW_INVENTORY = """
CREATE OR REPLACE VIEW vw_inventory_summary AS
  SELECT m.medicine_id, m.name, m.pharma_form, m.strength, m.unit_price, NVL(i.qty,0) AS qty, m.expiry_date
  FROM Medicines m LEFT JOIN Inventory i ON m.medicine_id = i.medicine_id
"""

# --------------- Helper utilities ---------------
def safe_execute(cursor, sql: str, params: Optional[Tuple] = None, silent_on_exists: bool = False):
    """Execute SQL and handle 'already exists' gracefully if requested."""
    try:
        if params:
            cursor.execute(sql, params)
        else:
            cursor.execute(sql)
    except Exception as e:
        msg = str(e).lower()
        if silent_on_exists and ("already exists" in msg or "ora-00955" in msg):
            log.debug("Object already exists (ignored): %s", e)
        else:
            log.exception("SQL execution error: %s", e)
            raise

def fetch_all_scalar(cur, sql: str, params: Optional[Tuple] = None) -> List[Tuple]:
    cur.execute(sql, params or {})
    return cur.fetchall()

# --------------- Main DB class ---------------
class PharmacyDB:
    def __init__(self, user=DB_USER, password=DB_PASS, dsn=DB_DSN, min_pool=1, max_pool=4):
        self.user = user
        self.password = password
        self.dsn = dsn
        self.pool = None
        self._connect(min_pool, max_pool)

    def _connect(self, min_pool: int = 1, max_pool: int = 4):
        try:
            # Create a session pool for better concurrency than single connection.
            self.pool = cx_Oracle.SessionPool(user=self.user, password=self.password, dsn=self.dsn,
                                              min=min_pool, max=max_pool, increment=1, threaded=True)
            self._conn = self.pool.acquire()
            self._cur = self._conn.cursor()
            log.info("Connected to Oracle DB as %s", self.user)
        except Exception as e:
            log.exception("Failed to connect to DB: %s", e)
            sys.exit(1)

    def close(self):
        try:
            if self._cur:
                self._cur.close()
            if self._conn:
                self.pool.release(self._conn)
            if self.pool:
                self.pool.close()
            log.info("DB connection closed.")
        except Exception:
            log.exception("Error while closing DB resources.")

    def cursor(self):
        """Return a dedicated cursor — caller must close it."""
        return self.pool.acquire().cursor()

    # ---------- Schema & Setup ----------
    def ensure_schema(self):
        """Create tables, constraints, and the inventory view — idempotent safe."""
        log.info("Ensuring database schema...")
        cur = self._cur
        safe_execute(cur, SQL_CREATE_SUPPLIERS, silent_on_exists=True)
        safe_execute(cur, SQL_CREATE_CUSTOMERS, silent_on_exists=True)
        safe_execute(cur, SQL_CREATE_MEDICINES, silent_on_exists=True)
        safe_execute(cur, SQL_CREATE_INVENTORY, silent_on_exists=True)
        safe_execute(cur, SQL_CREATE_ORDERS, silent_on_exists=True)
        safe_execute(cur, SQL_CREATE_ORDER_ITEMS, silent_on_exists=True)
        safe_execute(cur, SQL_CREATE_AUDIT, silent_on_exists=True)
        # add check constraint (ignore on exists)
        try:
            safe_execute(cur, SQL_CHK_PRICE)
        except Exception:
            log.debug("chk_price may already exist, ignored.")
        # indexes to speed up common queries
        try:
            safe_execute(cur, "CREATE INDEX idx_medicine_supplier ON Medicines(supplier_id)", silent_on_exists=True)
            safe_execute(cur, "CREATE INDEX idx_order_customer ON Orders(customer_id)", silent_on_exists=True)
            safe_execute(cur, "CREATE INDEX idx_order_date ON Orders(order_date)", silent_on_exists=True)
        except Exception:
            log.debug("Index creation issue ignored.")
        # view
        safe_execute(cur, SQL_CREATE_VW_INVENTORY)
        self._conn.commit()
        log.info("Schema ensured.")

    # ---------- Data seeding ----------
    def seed_sample_data(self):
        """Insert sample suppliers, customers, medicines and inventory if not present."""
        log.info("Seeding sample data (if missing)...")
        cur = self._cur
        try:
            # Simple upsert-like logic: insert but ignore duplicates by catching error
            safe_execute(cur, "INSERT INTO Suppliers(name, contact_email, phone) VALUES(:1, :2, :3)",
                         ("Cipla Ltd.", "sales@cipla.com", "+91-9876543210"))
            safe_execute(cur, "INSERT INTO Suppliers(name, contact_email, phone) VALUES(:1, :2, :3)",
                         ("Sun Pharma", "support@sunpharma.com", "+91-9123456780"))
            safe_execute(cur, "INSERT INTO Customers(name, phone, email, address) VALUES(:1,:2,:3,:4)",
                         ("John Doe", "9998887776", "john@example.com", "23 Green Street, Vellore"))

            # Medicines with expiry dates
            meds = [
                ("Paracetamol", "Tablet", "500 mg", 2.50, 1, "2026-02-15"),
                ("Amoxicillin", "Capsule", "250 mg", 5.00, 2, "2025-12-01"),
                ("OldSyrup", "Syrup", "100 ml", 40.00, 2, "2020-01-01")
            ]
            for name, form, strg, price, supid, expiry in meds:
                safe_execute(cur, """
                    INSERT INTO Medicines(name, pharma_form, strength, unit_price, supplier_id, expiry_date)
                    VALUES(:1,:2,:3,:4,:5,TO_DATE(:6,'YYYY-MM-DD'))""",
                             (name, form, strg, price, supid, expiry))
            self._conn.commit()
            # Create inventory rows for all medicines (if missing)
            cur.execute("SELECT medicine_id FROM Medicines")
            meds_ids = [r[0] for r in cur.fetchall()]
            for mid in meds_ids:
                try:
                    safe_execute(cur, "INSERT INTO Inventory(medicine_id, qty, min_threshold) VALUES(:1, :2, :3)",
                                 (mid, 50, 10))
                except Exception:
                    # likely already exists
                    pass
            self._conn.commit()
            log.info("Seed data created/ensured.")
        except Exception:
            log.exception("Seeding data encountered an issue.")
            self._conn.rollback()

    # ---------- Triggers ----------
    def ensure_triggers(self):
        """Create triggers for expiry protection and audits."""
        log.info("Creating/ensuring triggers...")
        cur = self._cur
        try:
            safe_execute(cur, """
            CREATE OR REPLACE TRIGGER trg_med_before_ins
            BEFORE INSERT OR UPDATE ON Medicines
            FOR EACH ROW
            DECLARE
              e_expired EXCEPTION;
            BEGIN
              IF :NEW.expiry_date IS NOT NULL AND :NEW.expiry_date < TRUNC(SYSDATE) THEN
                 RAISE e_expired;
              END IF;
              :NEW.name := UPPER(:NEW.name);
            EXCEPTION
              WHEN e_expired THEN
                RAISE_APPLICATION_ERROR(-20050, 'Cannot insert/update expired medicine');
            END;
            """)
            safe_execute(cur, """
            CREATE OR REPLACE TRIGGER trg_audit_orders
            AFTER INSERT OR UPDATE OR DELETE ON Orders
            FOR EACH ROW
            BEGIN
              IF INSERTING THEN
                INSERT INTO Audit_Log(action_by, action, object_name, details) VALUES(USER,'INSERT','ORDERS','Order placed or inserted');
              ELSIF UPDATING THEN
                INSERT INTO Audit_Log(action_by, action, object_name, details) VALUES(USER,'UPDATE','ORDERS','Order updated');
              ELSIF DELETING THEN
                INSERT INTO Audit_Log(action_by, action, object_name, details) VALUES(USER,'DELETE','ORDERS','Order deleted');
              END IF;
            END;
            """)
            safe_execute(cur, """
            CREATE OR REPLACE TRIGGER trg_audit_medicines
            AFTER INSERT OR UPDATE OR DELETE ON Medicines
            FOR EACH ROW
            BEGIN
              IF INSERTING THEN
                INSERT INTO Audit_Log(action_by, action, object_name, details) VALUES(USER,'INSERT','MEDICINES','Inserted ' || :NEW.name);
              ELSIF UPDATING THEN
                INSERT INTO Audit_Log(action_by, action, object_name, details) VALUES(USER,'UPDATE','MEDICINES','Updated ' || :NEW.name);
              ELSIF DELETING THEN
                INSERT INTO Audit_Log(action_by, action, object_name, details) VALUES(USER,'DELETE','MEDICINES','Deleted ' || :OLD.name);
              END IF;
            END;
            """)
            self._conn.commit()
            log.info("Triggers created/updated.")
        except Exception:
            log.exception("Trigger creation failed.")
            self._conn.rollback()

    # ---------- Stored Procedures ----------
    def create_stored_procedures(self):
        """Create sp_place_order: robust order placement using collections & bulk operations."""
        log.info("Creating stored procedure sp_place_order...")
        cur = self._cur
        # This procedure uses SYS.ODCINUMBERLIST for inputs and does checks with BULK collection fetch.
        sp_sql = """
        CREATE OR REPLACE PROCEDURE sp_place_order (
          p_customer_id IN NUMBER,
          p_items IN SYS.ODCINUMBERLIST,
          p_qtys  IN SYS.ODCINUMBERLIST
        ) IS
          TYPE t_price_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
          TYPE t_qty_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
          v_price_tab t_price_tab;
          v_inv_tab   t_qty_tab;
          v_total NUMBER(12,2) := 0;
          v_order_id NUMBER;
        BEGIN
          IF p_items.COUNT != p_qtys.COUNT THEN
            RAISE_APPLICATION_ERROR(-20060, 'Items and quantities length mismatch');
          END IF;
          -- Bulk fetch prices and inventory for all item ids to avoid per-loop selects
          FOR i IN 1 .. p_items.COUNT LOOP
            SELECT unit_price INTO v_price_tab(i) FROM Medicines WHERE medicine_id = p_items(i);
            SELECT qty INTO v_inv_tab(i) FROM Inventory WHERE medicine_id = p_items(i);
            IF v_inv_tab(i) < p_qtys(i) THEN
              RAISE_APPLICATION_ERROR(-20061, 'Insufficient stock for medicine id ' || p_items(i));
            END IF;
            v_total := v_total + v_price_tab(i) * p_qtys(i);
          END LOOP;
          -- Insert order
          INSERT INTO Orders(customer_id, total_amount, status) VALUES(p_customer_id, v_total, 'COMPLETED') RETURNING order_id INTO v_order_id;
          -- Insert order items & update inventory
          FOR i IN 1 .. p_items.COUNT LOOP
            INSERT INTO Order_Items(order_id, medicine_id, quantity, unit_price, line_total)
            VALUES(v_order_id, p_items(i), p_qtys(i), v_price_tab(i), v_price_tab(i) * p_qtys(i));
            UPDATE Inventory SET qty = qty - p_qtys(i) WHERE medicine_id = p_items(i);
          END LOOP;
          INSERT INTO Audit_Log(action_by, action, object_name, details) VALUES(USER,'PROC','sp_place_order','Order ' || v_order_id || ' by ' || p_customer_id);
          COMMIT;
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR(-20062,'Medicine not found in procedure');
          WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
        END sp_place_order;
        """
        try:
            safe_execute(cur, sp_sql)
            self._conn.commit()
            log.info("Stored procedure created.")
        except Exception:
            log.exception("Failed to create stored procedure.")
            self._conn.rollback()

    # --------------- CRUD & Utility methods ---------------
    def add_medicine(self, name: str, pharma_form: str, strength: str, price: float, supplier_id: Optional[int], expiry: Optional[str]) -> Optional[int]:
        """Insert new medicine and ensure an inventory row exists. Returns medicine_id or None."""
        cur = self._cur
        try:
            if expiry:
                cur.execute("""
                    INSERT INTO Medicines(name, pharma_form, strength, unit_price, supplier_id, expiry_date)
                    VALUES(:1,:2,:3,:4,:5,TO_DATE(:6,'YYYY-MM-DD'))""",
                            (name.upper(), pharma_form, strength, price, supplier_id if supplier_id != 0 else None, expiry))
            else:
                cur.execute("""
                    INSERT INTO Medicines(name, pharma_form, strength, unit_price, supplier_id)
                    VALUES(:1,:2,:3,:4,:5)""",
                            (name.upper(), pharma_form, strength, price, supplier_id if supplier_id != 0 else None))
            # fetch last inserted ID (safe way using returning)
            cur.execute("SELECT medicine_id FROM Medicines WHERE ROWID = (SELECT MAX(ROWID) FROM Medicines)")
            row = cur.fetchone()
            mid = row[0] if row else None
            if mid is not None:
                try:
                    cur.execute("INSERT INTO Inventory(medicine_id, qty, min_threshold) VALUES(:1, :2, :3)", (mid, 0, 10))
                except Exception:
                    # inventory row may already exist
                    pass
            self._conn.commit()
            log.info("Medicine added id=%s name=%s", mid, name)
            return mid
        except Exception:
            log.exception("Error adding medicine.")
            self._conn.rollback()
            return None

    def update_stock(self, medicine_id: int, qty_delta: int):
        """Update inventory qty (can be negative)."""
        cur = self._cur
        try:
            cur.execute("UPDATE Inventory SET qty = NVL(qty,0) + :1 WHERE medicine_id = :2", (qty_delta, medicine_id))
            if cur.rowcount == 0:
                cur.execute("INSERT INTO Inventory(medicine_id, qty, min_threshold) VALUES(:1, :2, :3)", (medicine_id, qty_delta, 10))
            # audit entry
            cur.execute("INSERT INTO Audit_Log(action_by, action, object_name, details) VALUES(USER,'UPDATE','INVENTORY','Medicine '||:1||' qty change '||:2)", (medicine_id, qty_delta))
            self._conn.commit()
            log.info("Stock updated for med=%s delta=%s", medicine_id, qty_delta)
        except Exception:
            log.exception("Failed to update stock.")
            self._conn.rollback()

    def get_inventory_summary(self) -> List[Tuple]:
        cur = self._cur
        cur.execute("SELECT medicine_id, name, pharma_form, strength, unit_price, qty, expiry_date FROM vw_inventory_summary")
        return cur.fetchall()

    def get_low_stock(self) -> List[Tuple]:
        cur = self._cur
        cur.execute("""
          SELECT m.medicine_id, m.name, i.qty, i.min_threshold
          FROM Inventory i JOIN Medicines m ON i.medicine_id = m.medicine_id
          WHERE NVL(i.qty,0) <= NVL(i.min_threshold,10)
          ORDER BY i.qty ASC
        """)
        return cur.fetchall()

    def get_expiring(self) -> Tuple[List[Tuple], List[Tuple]]:
        cur = self._cur
        cur.execute("SELECT medicine_id, name, expiry_date FROM Medicines WHERE expiry_date < TRUNC(SYSDATE)")
        expired = cur.fetchall()
        cur.execute("SELECT medicine_id, name, expiry_date FROM Medicines WHERE expiry_date BETWEEN TRUNC(SYSDATE) AND TRUNC(SYSDATE)+90")
        near = cur.fetchall()
        return expired, near

    def create_invoice_callproc(self, customer_id: int, items: List[int], qtys: List[int]):
        """Call stored procedure sp_place_order with arrays."""
        if not items or not qtys or len(items) != len(qtys):
            raise ValueError("Items and qtys must be of equal non-zero length.")
        try:
            # create arrayvars and call proc
            arr_items = self._cur.arrayvar(cx_Oracle.NUMBER, items)
            arr_qtys = self._cur.arrayvar(cx_Oracle.NUMBER, qtys)
            self._cur.callproc("sp_place_order", [customer_id, arr_items, arr_qtys])
            log.info("Invoice created via stored proc for customer %s", customer_id)
        except Exception:
            log.exception("Error creating invoice (proc).")

    def view_orders(self) -> List[Tuple]:
        cur = self._cur
        cur.execute("""
          SELECT o.order_id, o.order_date, c.name, o.total_amount, o.status
          FROM Orders o LEFT JOIN Customers c ON o.customer_id = c.customer_id
          ORDER BY o.order_date DESC
        """)
        return cur.fetchall()

    def get_order_items(self, order_id: int) -> List[Tuple]:
        cur = self._cur
        cur.execute("SELECT medicine_id, quantity, unit_price, line_total FROM Order_Items WHERE order_id = :1", (order_id,))
        return cur.fetchall()

    def daily_sales_summary(self, days=7) -> List[Tuple]:
        cur = self._cur
        cur.execute("""
          SELECT TRUNC(order_date) sale_date, COUNT(*) orders, SUM(total_amount) total_sales, AVG(total_amount) avg_order
          FROM Orders
          WHERE order_date >= TRUNC(SYSDATE)-:1
          GROUP BY TRUNC(order_date)
          ORDER BY TRUNC(order_date) DESC
        """, (days,))
        return cur.fetchall()

# --------------- CLI Helpers ---------------
def prompt_int(prompt: str, default: Optional[int] = None) -> Optional[int]:
    s = input(prompt).strip()
    if s == "" and default is not None:
        return default
    try:
        return int(s)
    except ValueError:
        log.warning("Invalid number input.")
        return None

def prompt_float(prompt: str, default: Optional[float] = None) -> Optional[float]:
    s = input(prompt).strip()
    if s == "" and default is not None:
        return default
    try:
        return float(s)
    except ValueError:
        log.warning("Invalid decimal input.")
        return None

# --------------- Menus ---------------
def manage_inventory(db: PharmacyDB):
    actions = {
        "1": "Add New Medicine",
        "2": "Update Stock Quantity",
        "3": "View Inventory Summary",
        "4": "View Low Stock Items",
        "5": "View Expired / Near-Expiry Medicines",
        "6": "Back"
    }
    while True:
        print("\n--- Manage Inventory ---")
        for k, v in actions.items():
            print(f"{k}. {v}")
        ch = input("Enter choice: ").strip()
        if ch == "1":
            name = input("Name: ").strip()
            form = input("Form (Tablet/Syrup/...): ").strip()
            strength = input("Strength (e.g. 500 mg): ").strip()
            price = prompt_float("Unit price (₹): ", default=0.0)
            supplier_id = prompt_int("Supplier ID (or 0 for none): ", default=0) or 0
            expiry = input("Expiry date (YYYY-MM-DD) or blank: ").strip() or None
            mid = db.add_medicine(name, form, strength, price or 0.0, supplier_id, expiry)
            if mid:
                print(f"Medicine added with id: {mid}")
        elif ch == "2":
            mid = prompt_int("Medicine ID: ")
            qty = prompt_int("Quantity to add (negative to reduce): ")
            if mid is None or qty is None:
                print("Invalid input.")
            else:
                db.update_stock(mid, qty)
                print("Stock updated.")
        elif ch == "3":
            rows = db.get_inventory_summary()
            if not rows:
                print("No medicines found.")
            else:
                print(f"{'ID':<5} {'Name':<25} {'Form':<8} {'Str':<10} {'Price':<8} {'Qty':<5} {'Expiry':<12}")
                for r in rows:
                    mid, name, form, strength, price, qty, expiry = r
                    expiry_str = expiry.strftime("%Y-%m-%d") if expiry else "N/A"
                    print(f"{mid:<5} {name[:24]:<25} {form:<8} {strength:<10} {price:<8} {qty:<5} {expiry_str:<12}")
        elif ch == "4":
            rows = db.get_low_stock()
            if not rows:
                print("No low stock items.")
            else:
                for r in rows:
                    print(f"ID:{r[0]} | {r[1]} | Qty:{r[2]} | Threshold:{r[3]}")
        elif ch == "5":
            expired, near = db.get_expiring()
            if expired:
                print("EXPIRED MEDICINES:")
                for r in expired:
                    print(f"ID:{r[0]} | {r[1]} | Expiry:{r[2].strftime('%Y-%m-%d')}")
            else:
                print("No expired medicines.")
            if near:
                print("\nNEAR-EXPIRY (next 90 days):")
                for r in near:
                    print(f"ID:{r[0]} | {r[1]} | Expiry:{r[2].strftime('%Y-%m-%d')}")
        elif ch == "6":
            break
        else:
            print("Invalid choice")

def sales_menu(db: PharmacyDB):
    actions = {
        "1": "Create Customer Invoice (Place Order)",
        "2": "View Orders",
        "3": "Daily Sales Summary (report)",
        "4": "Back"
    }
    while True:
        print("\n--- Sales & Billing ---")
        for k, v in actions.items():
            print(f"{k}. {v}")
        ch = input("Enter choice: ").strip()
        if ch == "1":
            cid = prompt_int("Customer ID (enter 0 to create guest): ", default=0)
            if cid == 0:
                name = input("Guest name: ").strip() or "Guest"
                phone = input("Phone (optional): ").strip() or None
                # create quick guest
                cur = db._cur
                cur.execute("INSERT INTO Customers(name, phone) VALUES(:1, :2)", (name, phone))
                db._conn.commit()
                cur.execute("SELECT customer_id FROM Customers WHERE ROWID = (SELECT MAX(ROWID) FROM Customers)")
                cid = cur.fetchone()[0]
                print("Guest customer id:", cid)
            items = []
            qtys = []
            while True:
                mid = prompt_int("Medicine ID to add (0 to finish): ", default=0)
                if mid == 0:
                    break
                q = prompt_int("Quantity: ", default=1)
                if q is None:
                    continue
                items.append(mid)
                qtys.append(q)
            if not items:
                print("No items selected. Aborting invoice.")
                continue
            # call stored procedure
            try:
                db.create_invoice_callproc(cid, items, qtys)
                print("Invoice created and inventory updated.")
            except Exception:
                print("Error placing order. See logs.")
        elif ch == "2":
            orders = db.view_orders()
            if not orders:
                print("No orders found.")
            else:
                for r in orders:
                    oid, odate, cname, total, status = r
                    odate_str = odate.strftime("%Y-%m-%d") if odate else "N/A"
                    print(f"OrderID:{oid} | Date:{odate_str} | Customer:{cname} | Total:₹{total} | Status:{status}")
                    items = db.get_order_items(oid)
                    for it in items:
                        print(f"  - MedID:{it[0]} | Qty:{it[1]} | Unit:₹{it[2]} | Line:₹{it[3]}")
        elif ch == "3":
            rows = db.daily_sales_summary()
            if not rows:
                print("No recent sales.")
            else:
                for r in rows:
                    date_str = r[0].strftime('%Y-%m-%d')
                    print(f"{date_str} | Orders: {r[1]} | Sales: ₹{r[2]:.2f} | Avg order: ₹{r[3]:.2f}")
        elif ch == "4":
            break
        else:
            print("Invalid choice")

def supplier_menu(db: PharmacyDB):
    # Minimal supplier menu (extend as needed)
    while True:
        print("\n--- Supplier Management ---")
        print("1. List Suppliers")
        print("2. Back")
        ch = input("Enter choice: ").strip()
        if ch == "1":
            cur = db._cur
            cur.execute("SELECT supplier_id, name, contact_email, phone FROM Suppliers ORDER BY supplier_id")
            rows = cur.fetchall()
            if not rows:
                print("No suppliers.")
            else:
                for r in rows:
                    print(f"ID:{r[0]} | {r[1]} | {r[2]} | {r[3]}")
        elif ch == "2":
            break
        else:
            print("Invalid choice")

# --------------- Main App ---------------
def main():
    db = PharmacyDB()
    try:
        db.ensure_schema()
        db.seed_sample_data()
        db.ensure_triggers()
        db.create_stored_procedures()

        main_menu = {
            "1": ("Manage Inventory", lambda: manage_inventory(db)),
            "2": ("Sales & Billing", lambda: sales_menu(db)),
            "3": ("Supplier Management", lambda: supplier_menu(db)),
            "4": ("Exit", None)
        }

        while True:
            print("\n====== Pharmacy Management System ======")
            for k, (title, _) in main_menu.items():
                print(f"{k}. {title}")
            choice = input("Choose: ").strip()
            if choice == "4":
                print("Goodbye.")
                break
            action = main_menu.get(choice)
            if action:
                action[1]()  # call the function
            else:
                print("Invalid choice")

    finally:
        db.close()

if __name__ == "__main__":
    main()
